webpackJsonp([2],{dcCC:function(n,t){},eN2t:function(n,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=e("//Fk"),o=e.n(r),i={name:"promise",data:function(){return{}},computed:{},created:function(){var n=this;n.promiseFun().then(function(t){return console.log(t),n.promiseFun2()}).then(function(n){return console.log(n),"直接返回数据"}).then(function(n){console.log(3+n)})},watch:{},mounted:function(){},filters:{},methods:{promiseFun:function(){return new o.a(function(n,t){n("1我是数据")})},promiseFun2:function(){return"2直接返回数据"}}},s={render:function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"promise"},[this._m(0)])},staticRenderFns:[function(){var n=this.$createElement,t=this._self._c||n;return t("div",[this._v("\n        Promise 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。\n        "),t("br"),this._v("\n        那么，什么是Promises？\n        "),t("br"),this._v("\n        首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\n        "),t("br"),this._v("\n        简单说，它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\n    ")])}]},c=e("VU/8")(i,s,!1,function(n){e("dcCC")},"data-v-1cbd007f",null);t.default=c.exports}});